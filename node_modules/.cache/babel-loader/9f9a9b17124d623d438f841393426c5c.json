{"ast":null,"code":"function calcInset(element, container) {\n  var inset = {\n    x: 0,\n    y: 0\n  };\n  var current = element;\n\n  while (current && current !== container) {\n    if (current instanceof HTMLElement) {\n      inset.x += current.offsetLeft;\n      inset.y += current.offsetTop;\n      current = current.offsetParent;\n    } else if (current.tagName === \"svg\") {\n      /**\n       * This isn't an ideal approach to measuring the offset of <svg /> tags.\n       * It would be preferable, given they behave like HTMLElements in most ways\n       * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n       * can't use .getBBox() like most SVG elements as these provide the offset\n       * relative to the SVG itself, which for <svg /> is usually 0x0.\n       */\n      var svgBoundingBox = current.getBoundingClientRect();\n      current = current.parentElement;\n      var parentBoundingBox = current.getBoundingClientRect();\n      inset.x += svgBoundingBox.left - parentBoundingBox.left;\n      inset.y += svgBoundingBox.top - parentBoundingBox.top;\n    } else if (current instanceof SVGGraphicsElement) {\n      var _current$getBBox = current.getBBox(),\n          x = _current$getBBox.x,\n          y = _current$getBBox.y;\n\n      inset.x += x;\n      inset.y += y;\n      var svg = null;\n      var parent = current.parentNode;\n\n      while (!svg) {\n        if (parent.tagName === \"svg\") {\n          svg = parent;\n        }\n\n        parent = current.parentNode;\n      }\n\n      current = svg;\n    } else {\n      break;\n    }\n  }\n\n  return inset;\n}\n\nexport { calcInset };","map":null,"metadata":{},"sourceType":"module"}