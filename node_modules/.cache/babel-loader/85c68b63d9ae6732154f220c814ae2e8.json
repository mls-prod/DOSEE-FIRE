{"ast":null,"code":"import _toConsumableArray from \"C:/Users/wilfr/OneDrive/Documents/maxitapbotlatestversionv2/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { jsx, Fragment } from 'react/jsx-runtime';\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\nimport { invariant } from '../../utils/errors.mjs';\n\nvar getChildKey = function getChildKey(child) {\n  return child.key || \"\";\n};\n\nfunction updateChildLookup(children, allChildren) {\n  children.forEach(function (child) {\n    var key = getChildKey(child);\n    allChildren.set(key, child);\n  });\n}\n\nfunction onlyElements(children) {\n  var filtered = []; // We use forEach here instead of map as map mutates the component key by preprending `.$`\n\n  Children.forEach(children, function (child) {\n    if (isValidElement(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\n\n\nvar AnimatePresence = function AnimatePresence(_ref) {\n  var children = _ref.children,\n      custom = _ref.custom,\n      _ref$initial = _ref.initial,\n      initial = _ref$initial === void 0 ? true : _ref$initial,\n      onExitComplete = _ref.onExitComplete,\n      exitBeforeEnter = _ref.exitBeforeEnter,\n      _ref$presenceAffectsL = _ref.presenceAffectsLayout,\n      presenceAffectsLayout = _ref$presenceAffectsL === void 0 ? true : _ref$presenceAffectsL,\n      _ref$mode = _ref.mode,\n      mode = _ref$mode === void 0 ? \"sync\" : _ref$mode;\n  invariant(!exitBeforeEnter, \"Replace exitBeforeEnter with mode='wait'\"); // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n\n  var forceRender = useContext(LayoutGroupContext).forceRender || useForceUpdate()[0];\n  var isMounted = useIsMounted(); // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n\n  var filteredChildren = onlyElements(children);\n  var childrenToRender = filteredChildren;\n  var exitingChildren = useRef(new Map()).current; // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n\n  var presentChildren = useRef(childrenToRender); // A lookup table to quickly reference components by key\n\n  var allChildren = useRef(new Map()).current; // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n\n  var isInitialRender = useRef(true);\n  useIsomorphicLayoutEffect(function () {\n    isInitialRender.current = false;\n    updateChildLookup(filteredChildren, allChildren);\n    presentChildren.current = childrenToRender;\n  });\n  useUnmountEffect(function () {\n    isInitialRender.current = true;\n    allChildren.clear();\n    exitingChildren.clear();\n  });\n\n  if (isInitialRender.current) {\n    return jsx(Fragment, {\n      children: childrenToRender.map(function (child) {\n        return jsx(PresenceChild, {\n          isPresent: true,\n          initial: initial ? undefined : false,\n          presenceAffectsLayout: presenceAffectsLayout,\n          mode: mode,\n          children: child\n        }, getChildKey(child));\n      })\n    });\n  } // If this is a subsequent render, deal with entering and exiting children\n\n\n  childrenToRender = _toConsumableArray(childrenToRender); // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n\n  var presentKeys = presentChildren.current.map(getChildKey);\n  var targetKeys = filteredChildren.map(getChildKey); // Diff the present children with our target children and mark those that are exiting\n\n  var numPresent = presentKeys.length;\n\n  for (var i = 0; i < numPresent; i++) {\n    var key = presentKeys[i];\n\n    if (targetKeys.indexOf(key) === -1 && !exitingChildren.has(key)) {\n      exitingChildren.set(key, undefined);\n    }\n  } // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n\n\n  if (mode === \"wait\" && exitingChildren.size) {\n    childrenToRender = [];\n  } // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n\n\n  exitingChildren.forEach(function (component, key) {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    var child = allChildren.get(key);\n    if (!child) return;\n    var insertionIndex = presentKeys.indexOf(key);\n    var exitingComponent = component;\n\n    if (!exitingComponent) {\n      var onExit = function onExit() {\n        // clean up the exiting children map\n        exitingChildren.delete(key); // compute the keys of children that were rendered once but are no longer present\n        // this could happen in case of too many fast consequent renderings\n        // @link https://github.com/framer/motion/issues/2023\n\n        var leftOverKeys = Array.from(allChildren.keys()).filter(function (childKey) {\n          return !targetKeys.includes(childKey);\n        }); // clean up the all children map\n\n        leftOverKeys.forEach(function (leftOverKey) {\n          return allChildren.delete(leftOverKey);\n        }); // make sure to render only the children that are actually visible\n\n        presentChildren.current = filteredChildren.filter(function (presentChild) {\n          var presentChildKey = getChildKey(presentChild);\n          return (// filter out the node exiting\n            presentChildKey === key || // filter out the leftover children\n            leftOverKeys.includes(presentChildKey)\n          );\n        }); // Defer re-rendering until all exiting children have indeed left\n\n        if (!exitingChildren.size) {\n          if (isMounted.current === false) return;\n          forceRender();\n          onExitComplete && onExitComplete();\n        }\n      };\n\n      exitingComponent = jsx(PresenceChild, {\n        isPresent: false,\n        onExitComplete: onExit,\n        custom: custom,\n        presenceAffectsLayout: presenceAffectsLayout,\n        mode: mode,\n        children: child\n      }, getChildKey(child));\n      exitingChildren.set(key, exitingComponent);\n    }\n\n    childrenToRender.splice(insertionIndex, 0, exitingComponent);\n  }); // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n\n  childrenToRender = childrenToRender.map(function (child) {\n    var key = child.key;\n    return exitingChildren.has(key) ? child : jsx(PresenceChild, {\n      isPresent: true,\n      presenceAffectsLayout: presenceAffectsLayout,\n      mode: mode,\n      children: child\n    }, getChildKey(child));\n  });\n\n  if (process.env.NODE_ENV !== \"production\" && mode === \"wait\" && childrenToRender.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its mode is set to \\\"wait\\\". This will lead to odd visual behaviour.\");\n  }\n\n  return jsx(Fragment, {\n    children: exitingChildren.size ? childrenToRender : childrenToRender.map(function (child) {\n      return cloneElement(child);\n    })\n  });\n};\n\nexport { AnimatePresence };","map":null,"metadata":{},"sourceType":"module"}